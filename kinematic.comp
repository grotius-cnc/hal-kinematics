component kinematic "kinematic component";

description 
"""
kinematic component

Compile slogan :
/opt/linuxcnc/bin/halcompile --compile /opt/linuxcnc/src/hal/components/kinematic.comp

Preprocess slogan :
/opt/linuxcnc/bin/halcompile --preprocess /opt/linuxcnc/src/hal/components/kinematic.comp

/opt/linuxcnc/bin/halcompile --preprocess /home/user/Desktop/Linux-Embedded/linux-hal/halcompile-kinematic/kinematic.comp


Then copy it to the rtlib.

Then in halview : loadrt kinematic

Usage :

""";
 
author "Skynet 2021";

license "GPLv2 or greater";

option singleton yes;

// *******************************************************
// Machine model
// *******************************************************

pin out bit init			"init values at component startup";
pin in bit reset			"reset all values to initialisation values";
param rw float interval		"calculation interval, 0ms=servo-thread, 2000ms=every 2sec, units ms";

param rw float j0_x			"joint 0, x_input";		
param rw float j0_y			"joint 0, y_input";
param rw float j0_z			"joint 0, z_input";

param rw float j0_init		"joint 0, initial degrees";
param rw float j0_cur		"joint 0, current degrees";
param rw float j0_min		"joint 0, min degrees";
param rw float j0_max		"joint 0, max degrees";

param rw float j1_x			"joint 1, x_input";		
param rw float j1_y			"joint 1, y_input";
param rw float j1_z			"joint 1, z_input";

param rw float j1_init		"joint 1, initial degrees";
param rw float j1_cur		"joint 1, current degrees";
param rw float j1_min		"joint 1, min degrees";
param rw float j1_max		"joint 1, max degrees";

param rw float j2_x			"joint 2, x_input";		
param rw float j2_y			"joint 2, y_input";
param rw float j2_z			"joint 2, z_input";

param rw float j2_init		"joint 2, initial degrees";
param rw float j2_cur		"joint 2, current degrees";
param rw float j2_min		"joint 2, min degrees";
param rw float j2_max		"joint 2, max degrees";

param rw float j3_x			"joint 3, x_input";		
param rw float j3_y			"joint 3, y_input";
param rw float j3_z			"joint 3, z_input";

param rw float j3_init		"joint 3, initial degrees";
param rw float j3_cur		"joint 3, current degrees";
param rw float j3_min		"joint 3, min degrees";
param rw float j3_max		"joint 3, max degrees";

param rw float j4_x			"joint 4, x_input";		
param rw float j4_y			"joint 4, y_input";
param rw float j4_z			"joint 4, z_input";

param rw float j4_init		"joint 4, initial degrees";
param rw float j4_cur		"joint 4, current degrees";
param rw float j4_min		"joint 4, min degrees";
param rw float j4_max		"joint 4, max degrees";

param rw float j5_x			"joint 5, x_input";		
param rw float j5_y			"joint 5, y_input";
param rw float j5_z			"joint 5, z_input";

param rw float j5_init		"joint 5, initial degrees";
param rw float j5_cur		"joint 5, current degrees";
param rw float j5_min		"joint 5, min degrees";
param rw float j5_max		"joint 5, max degrees";

// *******************************************************
// Machine calculation values
// *******************************************************

param rw float j0_			"joint 0 position";
param rw float j1_			"joint 1 position";
param rw float j2_			"joint 2 position";
param rw float j3_			"joint 3 position";
param rw float j4_			"joint 4 position";
param rw float j5_			"joint 5 position";

param rw float cart_x		"machine cartesian x";
param rw float cart_y		"machine cartesian y";
param rw float cart_z		"machine cartesian z";

param rw float euler_x		"machine euler angle x";
param rw float euler_y		"machine euler angle y";
param rw float euler_z		"machine euler angle z";

// *******************************************************
// Component control pins
// *******************************************************

pin in bit perform_fk		"calculate the forward kinematics from the joint input values";
pin in bit perform_ik		"calculate the inverse kinematics from the xyz and euler input values";



function _;

;;

#include "rtapi_math.h"
#include "kinematic.h"

double ms;
double seconds;
double totalnsec;
struct data d; // Component wide data bucket
struct data temp;

FUNCTION(_) {
        totalnsec = totalnsec + period;
        ms = totalnsec * 0.000001;          // rtapi_print_msg(RTAPI_MSG_ERR,"totalms: %f \n", totalms);
        seconds = totalnsec * 0.000000001;  // rtapi_print_msg(RTAPI_MSG_ERR,"totalseconds: %f \n", totalseconds);
        
        if(ms==interval){                   // edit the machinemodel.hal file for interval settings.

            if(!init){
                // Copy the machinemodel.hal values into the data bucket.

                d.J0_x=j0_x;
                d.J0_y=j0_y;
                d.J0_z=j0_z;
                d.J0_init=j0_init*toRadians;
                d.J0_cur=j0_cur*toRadians;
                d.J0_min=j0_min*toRadians;
                d.J0_max=j0_max*toRadians;

                d.J1_x=j1_x;
                d.J1_y=j1_y;
                d.J1_z=j1_z;
                d.J1_init=j1_init*toRadians;
                d.J1_cur=j1_cur*toRadians;
                d.J1_min=j1_min*toRadians;
                d.J1_max=j1_max*toRadians;

                d.J2_x=j2_x;
                d.J2_y=j2_y;
                d.J2_z=j2_z;
                d.J2_init=j2_init*toRadians;
                d.J2_cur=j2_cur*toRadians;
                d.J2_min=j2_min*toRadians;
                d.J2_max=j2_max*toRadians;

                d.J3_x=j3_x;
                d.J3_y=j3_y;
                d.J3_z=j3_z;
                d.J3_init=j3_init*toRadians;
                d.J3_cur=j3_cur*toRadians;
                d.J3_min=j3_min*toRadians;
                d.J3_max=j3_max*toRadians;

                d.J4_x=j4_x;
                d.J4_y=j4_y;
                d.J4_z=j4_z;
                d.J4_init=j4_init*toRadians;
                d.J4_cur=j4_cur*toRadians;
                d.J4_min=j4_min*toRadians;
                d.J4_max=j4_max*toRadians;

                d.J5_x=j5_x;
                d.J5_y=j5_y;
                d.J5_z=j5_z;
                d.J5_init=j5_init*toRadians;
                d.J5_cur=j5_cur*toRadians;
                d.J5_min=j5_min*toRadians;
                d.J5_max=j5_max*toRadians;

                d.Fk_mode=perform_fk; // Forward kinematics selected.
                d.Ik_mode=perform_ik;

                struct data r=init_wrapper(d);
                temp=d; // Save original init data if user want's a reset.

                rtapi_print_msg(RTAPI_MSG_ERR,"MACHINE SETUP VALUES AFTER FIRST FORWARD KINEMATICS (fk): \n");
                rtapi_print_msg(RTAPI_MSG_ERR,"J0: %f \n", r.J0*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J1: %f \n", r.J1*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J2: %f \n", r.J2*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J3: %f \n", r.J3*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J4: %f \n", r.J4*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J5: %f \n", r.J5*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart x: %f \n", r.Cartx);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart y: %f \n", r.Carty);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart z: %f \n", r.Cartz);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler x: %f \n", r.Eulerx*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler y: %f \n", r.Eulery*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler z: %f \n", r.Eulerz*toDegrees);

                // Update hal pins.
                j0_=r.J0*toDegrees;
                j1_=r.J1*toDegrees;
                j2_=r.J2*toDegrees;
                j3_=r.J3*toDegrees;
                j4_=r.J4*toDegrees;
                j5_=r.J5*toDegrees;
                cart_x=r.Cartx;
                cart_y=r.Carty;
                cart_z=r.Cartz;
                euler_x=r.Eulerx;
                euler_y=r.Eulery;
                euler_z=r.Eulerz;

                init=1; // The machine model setup data is known now.
            }

            if(init==1 && reset){
                d=temp;
            }

            // Forward kinematic request.
            if(init==1 && d.Fk_mode){
                d.J0=j0_*toRadians; // halpin float in.
                d.J1=j1_*toRadians;
                d.J2=j2_*toRadians;
                d.J3=j3_*toRadians;
                d.J4=j4_*toRadians;
                d.J5=j5_*toRadians;
                struct data r=fk_wrapper(d);

                // Write result(r) to hal output pins.
                j0_=r.J0*toDegrees;
                j1_=r.J1*toDegrees;
                j2_=r.J2*toDegrees;
                j3_=r.J3*toDegrees;
                j4_=r.J4*toDegrees;
                j5_=r.J5*toDegrees;
                cart_x=r.Cartx;
                cart_y=r.Carty;
                cart_z=r.Cartz;
                euler_x=r.Eulerx*toDegrees;
                euler_y=r.Eulery*toDegrees;
                euler_z=r.Eulerz*toDegrees;

                rtapi_print_msg(RTAPI_MSG_ERR,"FK RESULT: \n");
                rtapi_print_msg(RTAPI_MSG_ERR,"J0: %f \n", r.J0*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J1: %f \n", r.J1*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J2: %f \n", r.J2*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J3: %f \n", r.J3*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J4: %f \n", r.J4*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J5: %f \n", r.J5*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart x: %f \n", r.Cartx);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart y: %f \n", r.Carty);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart z: %f \n", r.Cartz);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler x: %f \n", r.Eulerx*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler y: %f \n", r.Eulery*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler z: %f \n", r.Eulerz*toDegrees);

                d=r; // Update the data bucket values.
            }

            // Inverse kinematic request.
            if(init==1 && d.Ik_mode){

                d.Cartx=cart_x;
                d.Carty=cart_y;
                d.Cartz=cart_z;
                d.Eulerx=euler_x*toRadians;
                d.Eulery=euler_y*toRadians;
                d.Eulerz=euler_z*toRadians;

                struct data r=ik_wrapper(d);
                
                // Write result(r) to hal output pins.
                j0_=r.J0*toDegrees;
                j1_=r.J1*toDegrees;
                j2_=r.J2*toDegrees;
                j3_=r.J3*toDegrees;
                j4_=r.J4*toDegrees;
                j5_=r.J5*toDegrees;
                cart_x=r.Cartx;
                cart_y=r.Carty;
                cart_z=r.Cartz;
                euler_x=r.Eulerx*toDegrees;
                euler_y=r.Eulery*toDegrees;
                euler_z=r.Eulerz*toDegrees;
                
                rtapi_print_msg(RTAPI_MSG_ERR,"IK RESULT: \n");
                rtapi_print_msg(RTAPI_MSG_ERR,"J0: %f \n", r.J0*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J1: %f \n", r.J1*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J2: %f \n", r.J2*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J3: %f \n", r.J3*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J4: %f \n", r.J4*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J5: %f \n", r.J5*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart x: %f \n", r.Cartx);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart y: %f \n", r.Carty);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart z: %f \n", r.Cartz);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler x: %f \n", r.Eulerx*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler y: %f \n", r.Eulery*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler z: %f \n", r.Eulerz*toDegrees);
                
                d=r; // Update the data bucket values.
            }
            totalnsec=0;
        }
}





















