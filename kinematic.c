/* Autogenerated by /opt/linuxcnc/bin/halcompile on Fri Jun 25 14:49:09 2021 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:kinematic:kinematic component");
MODULE_INFO(linuxcnc, "descr:\nkinematic component\n\nCompile slogan :\n/opt/linuxcnc/bin/halcompile --compile /opt/linuxcnc/src/hal/components/kinematic.comp\n\nPreprocess slogan :\n/opt/linuxcnc/bin/halcompile --preprocess /opt/linuxcnc/src/hal/components/kinematic.comp\n\n/opt/linuxcnc/bin/halcompile --preprocess /home/user/Desktop/Linux-Embedded/linux-hal/halcompile-kinematic/kinematic.comp\n\n\nThen copy it to the rtlib.\n\nThen in halview : loadrt kinematic\n\nUsage :\n\n");
MODULE_INFO(linuxcnc, "author:Skynet 2021");
MODULE_INFO(linuxcnc, "license:GPLv2 or greater");
MODULE_INFO(linuxcnc, "pin:init:bit:0:out:init values at component startup:None:None");
MODULE_INFO(linuxcnc, "pin:reset:bit:0:in:reset all values to initialisation values:None:None");
MODULE_INFO(linuxcnc, "param:interval:float:0:rw:calculation interval, 0ms=servo-thread, 2000ms=every 2sec, units ms:None:None");
MODULE_INFO(linuxcnc, "param:j0_x:float:0:rw:joint 0, x_input:None:None");
MODULE_INFO(linuxcnc, "param:j0_y:float:0:rw:joint 0, y_input:None:None");
MODULE_INFO(linuxcnc, "param:j0_z:float:0:rw:joint 0, z_input:None:None");
MODULE_INFO(linuxcnc, "param:j0_init:float:0:rw:joint 0, initial degrees:None:None");
MODULE_INFO(linuxcnc, "param:j0_cur:float:0:rw:joint 0, current degrees:None:None");
MODULE_INFO(linuxcnc, "param:j0_min:float:0:rw:joint 0, min degrees:None:None");
MODULE_INFO(linuxcnc, "param:j0_max:float:0:rw:joint 0, max degrees:None:None");
MODULE_INFO(linuxcnc, "param:j1_x:float:0:rw:joint 1, x_input:None:None");
MODULE_INFO(linuxcnc, "param:j1_y:float:0:rw:joint 1, y_input:None:None");
MODULE_INFO(linuxcnc, "param:j1_z:float:0:rw:joint 1, z_input:None:None");
MODULE_INFO(linuxcnc, "param:j1_init:float:0:rw:joint 1, initial degrees:None:None");
MODULE_INFO(linuxcnc, "param:j1_cur:float:0:rw:joint 1, current degrees:None:None");
MODULE_INFO(linuxcnc, "param:j1_min:float:0:rw:joint 1, min degrees:None:None");
MODULE_INFO(linuxcnc, "param:j1_max:float:0:rw:joint 1, max degrees:None:None");
MODULE_INFO(linuxcnc, "param:j2_x:float:0:rw:joint 2, x_input:None:None");
MODULE_INFO(linuxcnc, "param:j2_y:float:0:rw:joint 2, y_input:None:None");
MODULE_INFO(linuxcnc, "param:j2_z:float:0:rw:joint 2, z_input:None:None");
MODULE_INFO(linuxcnc, "param:j2_init:float:0:rw:joint 2, initial degrees:None:None");
MODULE_INFO(linuxcnc, "param:j2_cur:float:0:rw:joint 2, current degrees:None:None");
MODULE_INFO(linuxcnc, "param:j2_min:float:0:rw:joint 2, min degrees:None:None");
MODULE_INFO(linuxcnc, "param:j2_max:float:0:rw:joint 2, max degrees:None:None");
MODULE_INFO(linuxcnc, "param:j3_x:float:0:rw:joint 3, x_input:None:None");
MODULE_INFO(linuxcnc, "param:j3_y:float:0:rw:joint 3, y_input:None:None");
MODULE_INFO(linuxcnc, "param:j3_z:float:0:rw:joint 3, z_input:None:None");
MODULE_INFO(linuxcnc, "param:j3_init:float:0:rw:joint 3, initial degrees:None:None");
MODULE_INFO(linuxcnc, "param:j3_cur:float:0:rw:joint 3, current degrees:None:None");
MODULE_INFO(linuxcnc, "param:j3_min:float:0:rw:joint 3, min degrees:None:None");
MODULE_INFO(linuxcnc, "param:j3_max:float:0:rw:joint 3, max degrees:None:None");
MODULE_INFO(linuxcnc, "param:j4_x:float:0:rw:joint 4, x_input:None:None");
MODULE_INFO(linuxcnc, "param:j4_y:float:0:rw:joint 4, y_input:None:None");
MODULE_INFO(linuxcnc, "param:j4_z:float:0:rw:joint 4, z_input:None:None");
MODULE_INFO(linuxcnc, "param:j4_init:float:0:rw:joint 4, initial degrees:None:None");
MODULE_INFO(linuxcnc, "param:j4_cur:float:0:rw:joint 4, current degrees:None:None");
MODULE_INFO(linuxcnc, "param:j4_min:float:0:rw:joint 4, min degrees:None:None");
MODULE_INFO(linuxcnc, "param:j4_max:float:0:rw:joint 4, max degrees:None:None");
MODULE_INFO(linuxcnc, "param:j5_x:float:0:rw:joint 5, x_input:None:None");
MODULE_INFO(linuxcnc, "param:j5_y:float:0:rw:joint 5, y_input:None:None");
MODULE_INFO(linuxcnc, "param:j5_z:float:0:rw:joint 5, z_input:None:None");
MODULE_INFO(linuxcnc, "param:j5_init:float:0:rw:joint 5, initial degrees:None:None");
MODULE_INFO(linuxcnc, "param:j5_cur:float:0:rw:joint 5, current degrees:None:None");
MODULE_INFO(linuxcnc, "param:j5_min:float:0:rw:joint 5, min degrees:None:None");
MODULE_INFO(linuxcnc, "param:j5_max:float:0:rw:joint 5, max degrees:None:None");
MODULE_INFO(linuxcnc, "param:j0_:float:0:rw:joint 0 position:None:None");
MODULE_INFO(linuxcnc, "param:j1_:float:0:rw:joint 1 position:None:None");
MODULE_INFO(linuxcnc, "param:j2_:float:0:rw:joint 2 position:None:None");
MODULE_INFO(linuxcnc, "param:j3_:float:0:rw:joint 3 position:None:None");
MODULE_INFO(linuxcnc, "param:j4_:float:0:rw:joint 4 position:None:None");
MODULE_INFO(linuxcnc, "param:j5_:float:0:rw:joint 5 position:None:None");
MODULE_INFO(linuxcnc, "param:cart_x:float:0:rw:machine cartesian x:None:None");
MODULE_INFO(linuxcnc, "param:cart_y:float:0:rw:machine cartesian y:None:None");
MODULE_INFO(linuxcnc, "param:cart_z:float:0:rw:machine cartesian z:None:None");
MODULE_INFO(linuxcnc, "param:euler_x:float:0:rw:machine euler angle x:None:None");
MODULE_INFO(linuxcnc, "param:euler_y:float:0:rw:machine euler angle y:None:None");
MODULE_INFO(linuxcnc, "param:euler_z:float:0:rw:machine euler angle z:None:None");
MODULE_INFO(linuxcnc, "pin:perform_fk:bit:0:in:calculate the forward kinematics from the joint input values:None:None");
MODULE_INFO(linuxcnc, "pin:perform_ik:bit:0:in:calculate the inverse kinematics from the xyz and euler input values:None:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_LICENSE("GPLv2 or greater");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *init;
    hal_bit_t *reset;
    hal_bit_t *perform_fk;
    hal_bit_t *perform_ik;
    hal_float_t interval;
    hal_float_t j0_x;
    hal_float_t j0_y;
    hal_float_t j0_z;
    hal_float_t j0_init;
    hal_float_t j0_cur;
    hal_float_t j0_min;
    hal_float_t j0_max;
    hal_float_t j1_x;
    hal_float_t j1_y;
    hal_float_t j1_z;
    hal_float_t j1_init;
    hal_float_t j1_cur;
    hal_float_t j1_min;
    hal_float_t j1_max;
    hal_float_t j2_x;
    hal_float_t j2_y;
    hal_float_t j2_z;
    hal_float_t j2_init;
    hal_float_t j2_cur;
    hal_float_t j2_min;
    hal_float_t j2_max;
    hal_float_t j3_x;
    hal_float_t j3_y;
    hal_float_t j3_z;
    hal_float_t j3_init;
    hal_float_t j3_cur;
    hal_float_t j3_min;
    hal_float_t j3_max;
    hal_float_t j4_x;
    hal_float_t j4_y;
    hal_float_t j4_z;
    hal_float_t j4_init;
    hal_float_t j4_cur;
    hal_float_t j4_min;
    hal_float_t j4_max;
    hal_float_t j5_x;
    hal_float_t j5_y;
    hal_float_t j5_z;
    hal_float_t j5_init;
    hal_float_t j5_cur;
    hal_float_t j5_min;
    hal_float_t j5_max;
    hal_float_t j0_;
    hal_float_t j1_;
    hal_float_t j2_;
    hal_float_t j3_;
    hal_float_t j4_;
    hal_float_t j5_;
    hal_float_t cart_x;
    hal_float_t cart_y;
    hal_float_t cart_z;
    hal_float_t euler_x;
    hal_float_t euler_y;
    hal_float_t euler_z;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_bit_newf(HAL_OUT, &(inst->init), comp_id,
        "%s.init", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->reset), comp_id,
        "%s.reset", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->perform_fk), comp_id,
        "%s.perform-fk", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->perform_ik), comp_id,
        "%s.perform-ik", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->interval), comp_id,
        "%s.interval", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j0_x), comp_id,
        "%s.j0-x", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j0_y), comp_id,
        "%s.j0-y", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j0_z), comp_id,
        "%s.j0-z", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j0_init), comp_id,
        "%s.j0-init", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j0_cur), comp_id,
        "%s.j0-cur", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j0_min), comp_id,
        "%s.j0-min", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j0_max), comp_id,
        "%s.j0-max", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j1_x), comp_id,
        "%s.j1-x", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j1_y), comp_id,
        "%s.j1-y", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j1_z), comp_id,
        "%s.j1-z", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j1_init), comp_id,
        "%s.j1-init", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j1_cur), comp_id,
        "%s.j1-cur", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j1_min), comp_id,
        "%s.j1-min", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j1_max), comp_id,
        "%s.j1-max", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j2_x), comp_id,
        "%s.j2-x", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j2_y), comp_id,
        "%s.j2-y", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j2_z), comp_id,
        "%s.j2-z", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j2_init), comp_id,
        "%s.j2-init", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j2_cur), comp_id,
        "%s.j2-cur", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j2_min), comp_id,
        "%s.j2-min", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j2_max), comp_id,
        "%s.j2-max", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j3_x), comp_id,
        "%s.j3-x", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j3_y), comp_id,
        "%s.j3-y", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j3_z), comp_id,
        "%s.j3-z", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j3_init), comp_id,
        "%s.j3-init", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j3_cur), comp_id,
        "%s.j3-cur", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j3_min), comp_id,
        "%s.j3-min", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j3_max), comp_id,
        "%s.j3-max", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j4_x), comp_id,
        "%s.j4-x", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j4_y), comp_id,
        "%s.j4-y", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j4_z), comp_id,
        "%s.j4-z", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j4_init), comp_id,
        "%s.j4-init", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j4_cur), comp_id,
        "%s.j4-cur", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j4_min), comp_id,
        "%s.j4-min", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j4_max), comp_id,
        "%s.j4-max", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j5_x), comp_id,
        "%s.j5-x", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j5_y), comp_id,
        "%s.j5-y", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j5_z), comp_id,
        "%s.j5-z", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j5_init), comp_id,
        "%s.j5-init", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j5_cur), comp_id,
        "%s.j5-cur", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j5_min), comp_id,
        "%s.j5-min", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j5_max), comp_id,
        "%s.j5-max", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j0_), comp_id,
        "%s.j0", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j1_), comp_id,
        "%s.j1", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j2_), comp_id,
        "%s.j2", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j3_), comp_id,
        "%s.j3", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j4_), comp_id,
        "%s.j4", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->j5_), comp_id,
        "%s.j5", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->cart_x), comp_id,
        "%s.cart-x", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->cart_y), comp_id,
        "%s.cart-y", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->cart_z), comp_id,
        "%s.cart-z", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->euler_x), comp_id,
        "%s.euler-x", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->euler_y), comp_id,
        "%s.euler-y", prefix);
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->euler_z), comp_id,
        "%s.euler-z", prefix);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("kinematic");
    if(comp_id < 0) return comp_id;
    r = export("kinematic", 0);
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef init
#define init (*__comp_inst->init)
#undef reset
#define reset (0+*__comp_inst->reset)
#undef perform_fk
#define perform_fk (0+*__comp_inst->perform_fk)
#undef perform_ik
#define perform_ik (0+*__comp_inst->perform_ik)
#undef interval
#define interval (__comp_inst->interval)
#undef j0_x
#define j0_x (__comp_inst->j0_x)
#undef j0_y
#define j0_y (__comp_inst->j0_y)
#undef j0_z
#define j0_z (__comp_inst->j0_z)
#undef j0_init
#define j0_init (__comp_inst->j0_init)
#undef j0_cur
#define j0_cur (__comp_inst->j0_cur)
#undef j0_min
#define j0_min (__comp_inst->j0_min)
#undef j0_max
#define j0_max (__comp_inst->j0_max)
#undef j1_x
#define j1_x (__comp_inst->j1_x)
#undef j1_y
#define j1_y (__comp_inst->j1_y)
#undef j1_z
#define j1_z (__comp_inst->j1_z)
#undef j1_init
#define j1_init (__comp_inst->j1_init)
#undef j1_cur
#define j1_cur (__comp_inst->j1_cur)
#undef j1_min
#define j1_min (__comp_inst->j1_min)
#undef j1_max
#define j1_max (__comp_inst->j1_max)
#undef j2_x
#define j2_x (__comp_inst->j2_x)
#undef j2_y
#define j2_y (__comp_inst->j2_y)
#undef j2_z
#define j2_z (__comp_inst->j2_z)
#undef j2_init
#define j2_init (__comp_inst->j2_init)
#undef j2_cur
#define j2_cur (__comp_inst->j2_cur)
#undef j2_min
#define j2_min (__comp_inst->j2_min)
#undef j2_max
#define j2_max (__comp_inst->j2_max)
#undef j3_x
#define j3_x (__comp_inst->j3_x)
#undef j3_y
#define j3_y (__comp_inst->j3_y)
#undef j3_z
#define j3_z (__comp_inst->j3_z)
#undef j3_init
#define j3_init (__comp_inst->j3_init)
#undef j3_cur
#define j3_cur (__comp_inst->j3_cur)
#undef j3_min
#define j3_min (__comp_inst->j3_min)
#undef j3_max
#define j3_max (__comp_inst->j3_max)
#undef j4_x
#define j4_x (__comp_inst->j4_x)
#undef j4_y
#define j4_y (__comp_inst->j4_y)
#undef j4_z
#define j4_z (__comp_inst->j4_z)
#undef j4_init
#define j4_init (__comp_inst->j4_init)
#undef j4_cur
#define j4_cur (__comp_inst->j4_cur)
#undef j4_min
#define j4_min (__comp_inst->j4_min)
#undef j4_max
#define j4_max (__comp_inst->j4_max)
#undef j5_x
#define j5_x (__comp_inst->j5_x)
#undef j5_y
#define j5_y (__comp_inst->j5_y)
#undef j5_z
#define j5_z (__comp_inst->j5_z)
#undef j5_init
#define j5_init (__comp_inst->j5_init)
#undef j5_cur
#define j5_cur (__comp_inst->j5_cur)
#undef j5_min
#define j5_min (__comp_inst->j5_min)
#undef j5_max
#define j5_max (__comp_inst->j5_max)
#undef j0_
#define j0_ (__comp_inst->j0_)
#undef j1_
#define j1_ (__comp_inst->j1_)
#undef j2_
#define j2_ (__comp_inst->j2_)
#undef j3_
#define j3_ (__comp_inst->j3_)
#undef j4_
#define j4_ (__comp_inst->j4_)
#undef j5_
#define j5_ (__comp_inst->j5_)
#undef cart_x
#define cart_x (__comp_inst->cart_x)
#undef cart_y
#define cart_y (__comp_inst->cart_y)
#undef cart_z
#define cart_z (__comp_inst->cart_z)
#undef euler_x
#define euler_x (__comp_inst->euler_x)
#undef euler_y
#define euler_y (__comp_inst->euler_y)
#undef euler_z
#define euler_z (__comp_inst->euler_z)


#line 123 "/home/user/Desktop/Linux-Embedded/linux-hal/halcompile-kinematic/kinematic.comp"

#include "rtapi_math.h"
#include "kinematic.h"

double ms;
double seconds;
double totalnsec;
struct data d; // Component wide data bucket
struct data temp;

FUNCTION(_) {
        totalnsec = totalnsec + period;
        ms = totalnsec * 0.000001;          // rtapi_print_msg(RTAPI_MSG_ERR,"totalms: %f \n", totalms);
        seconds = totalnsec * 0.000000001;  // rtapi_print_msg(RTAPI_MSG_ERR,"totalseconds: %f \n", totalseconds);
        
        if(ms==interval){                   // edit the machinemodel.hal file for interval settings.

            if(!init){
                // Copy the machinemodel.hal values into the data bucket.

                d.J0_x=j0_x;
                d.J0_y=j0_y;
                d.J0_z=j0_z;
                d.J0_init=j0_init*toRadians;
                d.J0_cur=j0_cur*toRadians;
                d.J0_min=j0_min*toRadians;
                d.J0_max=j0_max*toRadians;

                d.J1_x=j1_x;
                d.J1_y=j1_y;
                d.J1_z=j1_z;
                d.J1_init=j1_init*toRadians;
                d.J1_cur=j1_cur*toRadians;
                d.J1_min=j1_min*toRadians;
                d.J1_max=j1_max*toRadians;

                d.J2_x=j2_x;
                d.J2_y=j2_y;
                d.J2_z=j2_z;
                d.J2_init=j2_init*toRadians;
                d.J2_cur=j2_cur*toRadians;
                d.J2_min=j2_min*toRadians;
                d.J2_max=j2_max*toRadians;

                d.J3_x=j3_x;
                d.J3_y=j3_y;
                d.J3_z=j3_z;
                d.J3_init=j3_init*toRadians;
                d.J3_cur=j3_cur*toRadians;
                d.J3_min=j3_min*toRadians;
                d.J3_max=j3_max*toRadians;

                d.J4_x=j4_x;
                d.J4_y=j4_y;
                d.J4_z=j4_z;
                d.J4_init=j4_init*toRadians;
                d.J4_cur=j4_cur*toRadians;
                d.J4_min=j4_min*toRadians;
                d.J4_max=j4_max*toRadians;

                d.J5_x=j5_x;
                d.J5_y=j5_y;
                d.J5_z=j5_z;
                d.J5_init=j5_init*toRadians;
                d.J5_cur=j5_cur*toRadians;
                d.J5_min=j5_min*toRadians;
                d.J5_max=j5_max*toRadians;

                d.Fk_mode=perform_fk; // Forward kinematics selected.
                d.Ik_mode=perform_ik;

                struct data r=init_wrapper(d);
                temp=d; // Save original init data if user want's a reset.

                rtapi_print_msg(RTAPI_MSG_ERR,"MACHINE SETUP VALUES AFTER FIRST FORWARD KINEMATICS (fk): \n");
                rtapi_print_msg(RTAPI_MSG_ERR,"J0: %f \n", r.J0*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J1: %f \n", r.J1*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J2: %f \n", r.J2*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J3: %f \n", r.J3*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J4: %f \n", r.J4*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J5: %f \n", r.J5*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart x: %f \n", r.Cartx);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart y: %f \n", r.Carty);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart z: %f \n", r.Cartz);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler x: %f \n", r.Eulerx*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler y: %f \n", r.Eulery*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler z: %f \n", r.Eulerz*toDegrees);

                // Update hal pins.
                j0_=r.J0*toDegrees;
                j1_=r.J1*toDegrees;
                j2_=r.J2*toDegrees;
                j3_=r.J3*toDegrees;
                j4_=r.J4*toDegrees;
                j5_=r.J5*toDegrees;
                cart_x=r.Cartx;
                cart_y=r.Carty;
                cart_z=r.Cartz;
                euler_x=r.Eulerx;
                euler_y=r.Eulery;
                euler_z=r.Eulerz;

                init=1; // The machine model setup data is known now.
            }

            if(init==1 && reset){
                d=temp;
            }

            // Forward kinematic request.
            if(init==1 && d.Fk_mode){
                d.J0=j0_*toRadians; // halpin float in.
                d.J1=j1_*toRadians;
                d.J2=j2_*toRadians;
                d.J3=j3_*toRadians;
                d.J4=j4_*toRadians;
                d.J5=j5_*toRadians;
                struct data r=fk_wrapper(d);

                // Write result(r) to hal output pins.
                j0_=r.J0*toDegrees;
                j1_=r.J1*toDegrees;
                j2_=r.J2*toDegrees;
                j3_=r.J3*toDegrees;
                j4_=r.J4*toDegrees;
                j5_=r.J5*toDegrees;
                cart_x=r.Cartx;
                cart_y=r.Carty;
                cart_z=r.Cartz;
                euler_x=r.Eulerx*toDegrees;
                euler_y=r.Eulery*toDegrees;
                euler_z=r.Eulerz*toDegrees;

                rtapi_print_msg(RTAPI_MSG_ERR,"FK RESULT: \n");
                rtapi_print_msg(RTAPI_MSG_ERR,"J0: %f \n", r.J0*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J1: %f \n", r.J1*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J2: %f \n", r.J2*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J3: %f \n", r.J3*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J4: %f \n", r.J4*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J5: %f \n", r.J5*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart x: %f \n", r.Cartx);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart y: %f \n", r.Carty);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart z: %f \n", r.Cartz);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler x: %f \n", r.Eulerx*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler y: %f \n", r.Eulery*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler z: %f \n", r.Eulerz*toDegrees);

                d=r; // Update the data bucket values.
            }

            // Inverse kinematic request.
            if(init==1 && d.Ik_mode){

                d.Cartx=cart_x;
                d.Carty=cart_y;
                d.Cartz=cart_z;
                d.Eulerx=euler_x*toRadians;
                d.Eulery=euler_y*toRadians;
                d.Eulerz=euler_z*toRadians;

                struct data r=ik_wrapper(d);
                
                // Write result(r) to hal output pins.
                j0_=r.J0*toDegrees;
                j1_=r.J1*toDegrees;
                j2_=r.J2*toDegrees;
                j3_=r.J3*toDegrees;
                j4_=r.J4*toDegrees;
                j5_=r.J5*toDegrees;
                cart_x=r.Cartx;
                cart_y=r.Carty;
                cart_z=r.Cartz;
                euler_x=r.Eulerx*toDegrees;
                euler_y=r.Eulery*toDegrees;
                euler_z=r.Eulerz*toDegrees;
                
                rtapi_print_msg(RTAPI_MSG_ERR,"IK RESULT: \n");
                rtapi_print_msg(RTAPI_MSG_ERR,"J0: %f \n", r.J0*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J1: %f \n", r.J1*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J2: %f \n", r.J2*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J3: %f \n", r.J3*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J4: %f \n", r.J4*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"J5: %f \n", r.J5*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart x: %f \n", r.Cartx);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart y: %f \n", r.Carty);
                rtapi_print_msg(RTAPI_MSG_ERR,"cart z: %f \n", r.Cartz);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler x: %f \n", r.Eulerx*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler y: %f \n", r.Eulery*toDegrees);
                rtapi_print_msg(RTAPI_MSG_ERR,"euler z: %f \n", r.Eulerz*toDegrees);
                
                d=r; // Update the data bucket values.
            }
            totalnsec=0;
        }
}






















static int __comp_get_data_size(void) { return 0; }
